/// <reference types="node" />
import * as net from 'net';
import * as tls from 'tls';
import * as url from 'url';
import { Observable } from 'rxjs/Observable';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
import { Event } from './event';
export declare class Connection extends ReplaySubject<Event> {
    private options;
    static readonly EOL: string;
    static readonly DEFAULT_ENCODING: string;
    private PrivateSocket;
    private state;
    constructor(options?: Connection.IOptions);
    readonly socket: tls.TLSSocket | net.Socket;
    /**
     * An observable that tracks the data being sent to the client
     */
    readonly data: Observable<string>;
    /**
     * An observable that tracks any telnet commands sent to the client
     */
    readonly commands: Observable<number[]>;
    /**
     * Sends the given string to the server.
     *
     * @param data the string to send to the server
     */
    send(data: string): void;
    /**
     * Sends the given string to the server and then sends an EOL ("\r\n").
     *
     * @param data the string to send to the server
     */
    sendln(data: string): void;
    /**
     * Connects to the server URI that was passed in with the constructor
     * @throws an error if the client cannot connect
     */
    connect(): tls.TLSSocket | net.Socket;
    /**
     * Close the telnet connection
     */
    disconnect(): void;
    /**
     * Return whether the underlying socket is connected
     */
    readonly connected: boolean;
    /**
     * Processes in-band telnet commands.  Please see the relevant RFCs for more information.
     * Commands are published to the connetion observable as {@link Event.Command} and
     * can be responded to by filtering for this information.
     *
     * @param data the array of data for the current input
     * @param position the current position of the data cursor
     * @returns the new position of the data cursor
     */
    private handleTelnetCommand(data, position);
    private connectNoTls(hostUrl);
    private connectTls(hostUrl);
    private sendDisconnecting();
    private sendDisconnected();
    private sendConnecting();
    private sendConnected();
}
export declare namespace Connection {
    interface IOptions {
        socket?: net.Socket | tls.TLSSocket;
        remoteUrl?: url.Url;
        connectionClass?: any;
    }
    type StateType = 'DISCONNECTED' | 'DISCONNECTING' | 'CONNECTING' | 'CONNECTED';
    class State {
        static Disconnected: 'DISCONNECTED';
        static Disconnecting: 'DISCONNECTING';
        static Connected: 'CONNECTED';
        static Connecting: 'CONNECTING';
    }
}
