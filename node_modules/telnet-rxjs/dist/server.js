"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var net = require("net");
var tls = require("tls");
var ReplaySubject_1 = require("rxjs/ReplaySubject");
var event_1 = require("./event");
var protocol_1 = require("./protocol");
var Server = /** @class */ (function (_super) {
    __extends(Server, _super);
    function Server(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.connections = [];
        return _this;
    }
    Server.prototype.start = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var protocol = _this.options.hostUrl.protocol;
            _this.next(new event_1.Event.Starting());
            switch (protocol) {
                case protocol_1.Protocol.TELNET:
                    _this.server = _this.serverNoTls(_this.options.hostUrl);
                    break;
                case protocol_1.Protocol.TELNETS:
                    _this.server = _this.serverTls(_this.options.hostUrl);
                    break;
            }
            if (!_this.server) {
                throw new Error('No hostUrl protocol has been supplied.');
            }
            _this.server.on('error', function (error) {
                _this.error(error);
            });
            _this.server.listen(Number(_this.options.hostUrl.port), _this.options.hostUrl.hostname, 5, function () {
                _this.next(new event_1.Event.Started());
                resolve(_this.server);
            });
        });
    };
    Server.prototype.stop = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.server) {
                resolve();
                return;
            }
            _this.next(new event_1.Event.Ending());
            if (_this.connections) {
                _this.connections.forEach(function (connection) {
                    connection.disconnect();
                });
            }
            _this.server.close(function () {
                resolve();
                _this.next(new event_1.Event.Ended());
            });
        });
    };
    Server.prototype.serverNoTls = function (hostUrl) {
        var _this = this;
        return net.createServer(__assign({}, this.options), function (conn) {
            _this.connectionFactory(conn);
        });
    };
    Server.prototype.serverTls = function (hostUrl) {
        var _this = this;
        return tls.createServer(__assign({}, this.options), function (conn) {
            _this.connectionFactory(conn);
        });
    };
    Server.prototype.connectionFactory = function (socket) {
        var _this = this;
        var connection = new this.options.clientClass({ socket: socket });
        connection.filter(function (event) { return event instanceof event_1.Event.Connected; })
            .subscribe(function (_) {
            _this.connections.push(connection);
            _this.next(new event_1.Event.Connected(connection));
        });
        connection.filter(function (event) { return event instanceof event_1.Event.Disconnected; })
            .subscribe(function (_) {
            var pos = _this.connections.indexOf(connection);
            if (pos !== -1) {
                _this.connections.splice(pos, 1);
            }
            _this.next(new event_1.Event.Disconnected(connection));
        });
        connection.connect();
    };
    return Server;
}(ReplaySubject_1.ReplaySubject));
exports.Server = Server;
//# sourceMappingURL=server.js.map