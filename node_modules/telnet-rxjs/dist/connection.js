"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var net = require("net");
var tls = require("tls");
var ReplaySubject_1 = require("rxjs/ReplaySubject");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/map");
var command_1 = require("./command");
var event_1 = require("./event");
var protocol_1 = require("./protocol");
var Connection = /** @class */ (function (_super) {
    __extends(Connection, _super);
    function Connection(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.state = Connection.State.Disconnected;
        if (options.socket) {
            _this.PrivateSocket = options.socket;
        }
        else {
            _this.PrivateSocket = new net.Socket();
        }
        if (_this.PrivateSocket.writable || _this.PrivateSocket.readable) {
            _this.state = Connection.State.Connected;
        }
        return _this;
    }
    Object.defineProperty(Connection.prototype, "socket", {
        get: function () {
            return this.PrivateSocket;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "data", {
        /**
         * An observable that tracks the data being sent to the client
         */
        get: function () {
            return this.filter(function (event) { return event instanceof event_1.Event.Data; })
                .map(function (event) { return event.data; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "commands", {
        /**
         * An observable that tracks any telnet commands sent to the client
         */
        get: function () {
            return this.filter(function (event) { return event instanceof event_1.Event.Command; })
                .map(function (event) { return event.command; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sends the given string to the server.
     *
     * @param data the string to send to the server
     */
    Connection.prototype.send = function (data) {
        if (!this.PrivateSocket) {
            return;
        }
        this.PrivateSocket.write(data);
    };
    /**
     * Sends the given string to the server and then sends an EOL ("\r\n").
     *
     * @param data the string to send to the server
     */
    Connection.prototype.sendln = function (data) {
        this.send(data);
        this.send(Connection.EOL);
    };
    /**
     * Connects to the server URI that was passed in with the constructor
     * @throws an error if the client cannot connect
     */
    Connection.prototype.connect = function () {
        var _this = this;
        if (!this.connected) {
            if (!this.options.remoteUrl) {
                throw new Error('No remoteUrl is defined');
            }
            this.sendConnecting();
            var protocol = this.options.remoteUrl.protocol || protocol_1.Protocol.TELNET;
            if (!this.options.remoteUrl.port) {
                throw new Error('A port is required to connect to.');
            }
            switch (protocol) {
                case protocol_1.Protocol.TELNET:
                    this.PrivateSocket = this.connectNoTls(this.options.remoteUrl);
                    break;
                case protocol_1.Protocol.TELNETS:
                    this.PrivateSocket = this.connectTls(this.options.remoteUrl);
                    break;
                default:
                    throw new Error(this.options.remoteUrl.protocol + ' is not a supported protocol');
            }
        }
        else {
            this.sendConnected();
        }
        this.PrivateSocket.on('error', function (error) {
            _this.error(error);
        });
        this.PrivateSocket.on('data', function (data) {
            var buffer = Buffer.alloc(data.length);
            var copied = 0;
            for (var cursor = 0; cursor < data.length; ++cursor) {
                if (data[cursor] === command_1.Command.IAC) {
                    cursor = _this.handleTelnetCommand(data, cursor);
                }
                else {
                    buffer[copied++] = data[cursor];
                }
            }
            _this.next(new event_1.Event.Data(buffer.toString(Connection.DEFAULT_ENCODING, 0, copied)));
        });
        /*
         * Close the connection if the server closes it
         */
        this.PrivateSocket.on('end', function () {
            _this.disconnect();
        });
        return this.PrivateSocket;
    };
    /**
     * Close the telnet connection
     */
    Connection.prototype.disconnect = function () {
        if (this.connected) {
            this.sendDisconnecting();
            this.PrivateSocket.end();
            this.PrivateSocket = new net.Socket();
            this.sendDisconnected();
        }
    };
    Object.defineProperty(Connection.prototype, "connected", {
        /**
         * Return whether the underlying socket is connected
         */
        get: function () {
            return this.state === Connection.State.Connected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes in-band telnet commands.  Please see the relevant RFCs for more information.
     * Commands are published to the connetion observable as {@link Event.Command} and
     * can be responded to by filtering for this information.
     *
     * @param data the array of data for the current input
     * @param position the current position of the data cursor
     * @returns the new position of the data cursor
     */
    Connection.prototype.handleTelnetCommand = function (data, position) {
        var telnetCommand = [command_1.Command.IAC];
        // Used to store the new position of the buffer cursor
        position++;
        if (data[position] === command_1.Command.SB) {
            while (position < data.length) {
                telnetCommand.push(data[position++]);
                if (data[position] === command_1.Command.SE) {
                    break;
                }
            }
        }
        else {
            if (position < data.length) {
                telnetCommand.push(data[position++]);
            }
            if (position < data.length) {
                telnetCommand.push(data[position++]);
            }
        }
        this.next(new event_1.Event.Command(telnetCommand));
        return position;
    };
    Connection.prototype.connectNoTls = function (hostUrl) {
        var _this = this;
        return net.connect(__assign({}, this.options, { host: hostUrl.hostname, port: Number(hostUrl.port) }), function () {
            _this.sendConnected();
        });
    };
    Connection.prototype.connectTls = function (hostUrl) {
        var _this = this;
        return tls.connect(__assign({}, this.options, { host: hostUrl.hostname, port: Number(hostUrl.port) }), function () {
            _this.sendConnected();
        });
    };
    Connection.prototype.sendDisconnecting = function () {
        this.state = Connection.State.Disconnecting;
        this.next(new event_1.Event.Disconnecting(this));
    };
    Connection.prototype.sendDisconnected = function () {
        this.state = Connection.State.Disconnected;
        this.next(new event_1.Event.Disconnected(this));
    };
    Connection.prototype.sendConnecting = function () {
        this.state = Connection.State.Connecting;
        this.next(new event_1.Event.Connecting(this));
    };
    Connection.prototype.sendConnected = function () {
        this.state = Connection.State.Connected;
        this.next(new event_1.Event.Connected(this));
    };
    Connection.EOL = '\r\n';
    Connection.DEFAULT_ENCODING = 'utf8';
    return Connection;
}(ReplaySubject_1.ReplaySubject));
exports.Connection = Connection;
(function (Connection) {
    var State = /** @class */ (function () {
        function State() {
        }
        State.Disconnected = 'DISCONNECTED';
        State.Disconnecting = 'DISCONNECTING';
        State.Connected = 'CONNECTED';
        State.Connecting = 'CONNECTING';
        return State;
    }());
    Connection.State = State;
})(Connection = exports.Connection || (exports.Connection = {}));
exports.Connection = Connection;
//# sourceMappingURL=connection.js.map